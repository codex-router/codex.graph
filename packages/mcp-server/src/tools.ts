import type { GraphIndex } from "./graph-loader.js";
import type { WorkflowEdge, WorkflowNode } from "./types.js";
import { topologicalSort } from "./topo-sort.js";

const NO_GRAPH = {
    error: "no_graph",
    message: "No Codag graph found. Open VS Code and run 'Codag: Open' to analyze the workspace first.",
    hint: "The graph is generated by the Codag VS Code extension and stored at .vscode/codag-graph.json",
};

// ---------------------------------------------------------------------------
// list_workflows
// ---------------------------------------------------------------------------

export function listWorkflows(index: GraphIndex | null) {
    if (!index) return NO_GRAPH;

    const { graph } = index;
    const workflows = graph.workflows.map((wf) => {
        const nodes = wf.nodeIds
            .map((id) => index.nodeById.get(id))
            .filter(Boolean) as WorkflowNode[];
        const files = new Set<string>();
        let hasLlmCalls = false;
        for (const n of nodes) {
            if (n.source?.file) files.add(n.source.file);
            if (n.type === "llm") hasLlmCalls = true;
        }
        return {
            id: wf.id,
            name: wf.name,
            description: wf.description ?? null,
            node_count: wf.nodeIds.length,
            has_llm_calls: hasLlmCalls,
            primary_files: [...files].slice(0, 5),
        };
    });

    return {
        workflows,
        total_nodes: graph.nodes.length,
        total_edges: graph.edges.length,
        llms_detected: graph.llms_detected,
    };
}

// ---------------------------------------------------------------------------
// get_workflow
// ---------------------------------------------------------------------------

export function getWorkflow(index: GraphIndex | null, workflowName: string) {
    if (!index) return NO_GRAPH;

    const { graph } = index;
    // Fuzzy match: case-insensitive substring
    const nameLower = workflowName.toLowerCase();
    const wf = graph.workflows.find(
        (w) =>
            w.name.toLowerCase() === nameLower ||
            w.id.toLowerCase() === nameLower ||
            w.name.toLowerCase().includes(nameLower)
    );

    if (!wf) {
        const available = graph.workflows.map((w) => w.name);
        return {
            error: "workflow_not_found",
            message: `No workflow matching "${workflowName}"`,
            available_workflows: available,
        };
    }

    const nodeSet = new Set(wf.nodeIds);
    const nodes = wf.nodeIds
        .map((id) => {
            const n = index.nodeById.get(id);
            if (!n) return null;
            return {
                id: n.id,
                label: n.label,
                type: n.type,
                file: n.source?.file ?? null,
                line: n.source?.line ?? null,
                function: n.source?.function ?? null,
                model: n.model ?? null,
                temperature: n.temperature ?? null,
                description: n.description ?? null,
            };
        })
        .filter(Boolean);

    const edges = graph.edges
        .filter((e) => nodeSet.has(e.source) && nodeSet.has(e.target))
        .map((e) => ({
            from: e.source,
            to: e.target,
            label: e.label ?? null,
            condition: e.condition ?? null,
        }));

    const topoOrder = topologicalSort(wf.nodeIds, graph.edges);

    return {
        workflow: {
            id: wf.id,
            name: wf.name,
            description: wf.description ?? null,
            nodes,
            edges,
            topological_order: topoOrder,
            components: wf.components ?? [],
        },
    };
}

// ---------------------------------------------------------------------------
// get_node
// ---------------------------------------------------------------------------

export function getNode(index: GraphIndex | null, nodeId: string) {
    if (!index) return NO_GRAPH;

    const node = index.nodeById.get(nodeId);
    if (!node) {
        // Try fuzzy: match by function name suffix
        const suffix = nodeId.toLowerCase();
        const match = [...index.nodeById.values()].find(
            (n) =>
                n.id.toLowerCase() === suffix ||
                n.id.toLowerCase().endsWith("::" + suffix) ||
                (n.source?.function?.toLowerCase() === suffix)
        );
        if (!match) {
            return {
                error: "node_not_found",
                message: `No node matching "${nodeId}"`,
                hint: "Use list_workflows or get_file_context to discover node IDs",
            };
        }
        return buildNodeResponse(index, match);
    }

    return buildNodeResponse(index, node);
}

function buildNodeResponse(index: GraphIndex, node: WorkflowNode) {
    const wf = index.nodeToWorkflow.get(node.id);
    const incoming = index.incomingEdges.get(node.id) ?? [];
    const outgoing = index.outgoingEdges.get(node.id) ?? [];

    return {
        node: {
            id: node.id,
            label: node.label,
            description: node.description ?? null,
            type: node.type,
            model: node.model ?? null,
            temperature: node.temperature ?? null,
            source: node.source ?? null,
        },
        workflow: wf ? { id: wf.id, name: wf.name } : null,
        inputs: incoming.map((e) => ({
            from_node: e.source,
            label: e.label ?? null,
        })),
        outputs: outgoing.map((e) => ({
            to_node: e.target,
            label: e.label ?? null,
        })),
    };
}

// ---------------------------------------------------------------------------
// get_file_context
// ---------------------------------------------------------------------------

export function getFileContext(index: GraphIndex | null, files: string[]) {
    if (!index) return NO_GRAPH;

    const results: Array<{
        file: string;
        workflows: string[];
        nodes: Array<{
            id: string;
            label: string;
            type: string;
            line: number | null;
            function: string | null;
        }>;
        llm_calls: Array<{
            node_id: string;
            model: string | null;
            line: number | null;
        }>;
        connected_files: string[];
    }> = [];
    const notFound: string[] = [];

    for (const file of files) {
        // Fuzzy match: try exact, then suffix match
        let nodes = index.fileToNodes.get(file);
        if (!nodes) {
            // Try suffix match (user might pass "src/api.ts" vs "frontend/src/api.ts")
            const fileLower = file.toLowerCase();
            for (const [key, val] of index.fileToNodes) {
                if (key.toLowerCase().endsWith(fileLower) || fileLower.endsWith(key.toLowerCase())) {
                    nodes = val;
                    break;
                }
            }
        }

        if (!nodes || nodes.length === 0) {
            notFound.push(file);
            continue;
        }

        const workflowNames = new Set<string>();
        const connectedFiles = new Set<string>();

        for (const n of nodes) {
            const wf = index.nodeToWorkflow.get(n.id);
            if (wf) workflowNames.add(wf.name);

            // Find connected files via edges
            for (const e of index.outgoingEdges.get(n.id) ?? []) {
                const target = index.nodeById.get(e.target);
                if (target?.source?.file) connectedFiles.add(target.source.file);
            }
            for (const e of index.incomingEdges.get(n.id) ?? []) {
                const source = index.nodeById.get(e.source);
                if (source?.source?.file) connectedFiles.add(source.source.file);
            }
        }

        // Remove self from connected files
        for (const n of nodes) {
            if (n.source?.file) connectedFiles.delete(n.source.file);
        }

        results.push({
            file,
            workflows: [...workflowNames],
            nodes: nodes.map((n) => ({
                id: n.id,
                label: n.label,
                type: n.type,
                line: n.source?.line ?? null,
                function: n.source?.function ?? null,
            })),
            llm_calls: nodes
                .filter((n) => n.type === "llm")
                .map((n) => ({
                    node_id: n.id,
                    model: n.model ?? null,
                    line: n.source?.line ?? null,
                })),
            connected_files: [...connectedFiles],
        });
    }

    return {
        files: results,
        files_not_in_graph: notFound,
        graph_timestamp: new Date(index.timestamp).toISOString(),
    };
}
