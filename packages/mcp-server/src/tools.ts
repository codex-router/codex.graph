import type { GraphIndex } from "./graph-loader.js";
import type { WorkflowEdge, WorkflowNode } from "./types.js";
import { topologicalSort } from "./topo-sort.js";

const NO_GRAPH = {
    error: "no_graph",
    message: "No Codag graph found. Open VS Code and run 'Codag: Open' to analyze the workspace first.",
    hint: "The graph is generated by the Codag VS Code extension and stored at .vscode/codag-graph.json",
};

// ---------------------------------------------------------------------------
// Call budget tracking
// ---------------------------------------------------------------------------

const SOFT_LIMIT = 6; // After this many calls to the same tool, nudge the agent

const callCounts = new Map<string, number>();

function trackCall(toolName: string): string | null {
    const count = (callCounts.get(toolName) ?? 0) + 1;
    callCounts.set(toolName, count);
    if (count === SOFT_LIMIT) {
        return `\n\n---\n⚠️ You've called ${toolName} ${count} times. You likely have enough context now — consider starting implementation.`;
    }
    if (count > SOFT_LIMIT) {
        const total = [...callCounts.values()].reduce((a, b) => a + b, 0);
        return `\n\n---\n⚠️ ${total} total Codag tool calls this session (${toolName}: ${count}). You have sufficient workflow context — start writing code.`;
    }
    return null;
}

export function wrapResult(toolName: string, data: unknown): string {
    const json = JSON.stringify(data, null, 2);
    const nudge = trackCall(toolName);
    return nudge ? json + nudge : json;
}

// ---------------------------------------------------------------------------
// initial_context — compact one-shot summary
// ---------------------------------------------------------------------------

export function initialContext(index: GraphIndex | null) {
    if (!index) return NO_GRAPH;

    const { graph } = index;

    // Compact workflow summaries
    const workflows = graph.workflows.map((wf) => {
        const nodes = wf.nodeIds
            .map((id) => index.nodeById.get(id))
            .filter(Boolean) as WorkflowNode[];
        const files = new Set<string>();
        const llmNodes: Array<{ fn: string; model: string | null; file: string }> = [];
        for (const n of nodes) {
            if (n.source?.file) files.add(n.source.file);
            if (n.type === "llm") {
                llmNodes.push({
                    fn: n.source?.function ?? n.label,
                    model: n.model ?? null,
                    file: n.source?.file ?? "",
                });
            }
        }
        return {
            name: wf.name,
            nodes: wf.nodeIds.length,
            files: [...files],
            llm_calls: llmNodes,
        };
    });

    // File → workflow mapping (compact)
    const fileMap: Record<string, string[]> = {};
    for (const wf of graph.workflows) {
        for (const nodeId of wf.nodeIds) {
            const node = index.nodeById.get(nodeId);
            if (node?.source?.file) {
                if (!fileMap[node.source.file]) fileMap[node.source.file] = [];
                if (!fileMap[node.source.file].includes(wf.name)) {
                    fileMap[node.source.file].push(wf.name);
                }
            }
        }
    }

    // Key cross-file edges
    const crossFileEdges: Array<{ from: string; to: string; label: string | null }> = [];
    for (const edge of graph.edges) {
        const src = index.nodeById.get(edge.source);
        const tgt = index.nodeById.get(edge.target);
        if (src?.source?.file && tgt?.source?.file && src.source.file !== tgt.source.file) {
            crossFileEdges.push({
                from: `${src.source.file}::${src.source.function ?? "?"}`,
                to: `${tgt.source.file}::${tgt.source.function ?? "?"}`,
                label: edge.label ?? null,
            });
        }
    }

    return {
        summary: {
            total_nodes: graph.nodes.length,
            total_edges: graph.edges.length,
            total_workflows: graph.workflows.length,
            llms_detected: graph.llms_detected,
        },
        workflows,
        file_to_workflows: fileMap,
        cross_file_edges: crossFileEdges.slice(0, 50), // Cap for token efficiency
        graph_timestamp: new Date(index.timestamp).toISOString(),
        hint: "Use get_file_context(files) for details on specific files you plan to modify. Use get_workflow(name) for full topology of a specific pipeline.",
    };
}

// ---------------------------------------------------------------------------
// Graph summary resource (for auto-injection into system prompt)
// ---------------------------------------------------------------------------

export function graphSummaryResource(index: GraphIndex | null): string {
    if (!index) return "No Codag graph available. Run the Codag VS Code extension to analyze the workspace.";

    const { graph } = index;
    const lines: string[] = [
        `# Codag Workflow Graph`,
        `${graph.nodes.length} nodes, ${graph.edges.length} edges, ${graph.workflows.length} workflows`,
        `LLMs: ${graph.llms_detected.join(", ") || "none"}`,
        ``,
        `## Workflows`,
    ];

    for (const wf of graph.workflows) {
        const nodes = wf.nodeIds
            .map((id) => index.nodeById.get(id))
            .filter(Boolean) as WorkflowNode[];
        const llmCount = nodes.filter((n) => n.type === "llm").length;
        const files = [...new Set(nodes.map((n) => n.source?.file).filter(Boolean))];
        lines.push(`- **${wf.name}** (${nodes.length} nodes, ${llmCount} LLM calls) — ${files.join(", ")}`);
    }

    lines.push("", "## Files with LLM Workflow Code");
    const fileSet = new Map<string, string[]>();
    for (const wf of graph.workflows) {
        for (const nodeId of wf.nodeIds) {
            const node = index.nodeById.get(nodeId);
            if (node?.source?.file) {
                if (!fileSet.has(node.source.file)) fileSet.set(node.source.file, []);
                if (!fileSet.get(node.source.file)!.includes(wf.name)) {
                    fileSet.get(node.source.file)!.push(wf.name);
                }
            }
        }
    }
    for (const [file, wfs] of fileSet) {
        lines.push(`- \`${file}\` → ${wfs.join(", ")}`);
    }

    return lines.join("\n");
}

// ---------------------------------------------------------------------------
// list_workflows
// ---------------------------------------------------------------------------

export function listWorkflows(index: GraphIndex | null) {
    if (!index) return NO_GRAPH;

    const { graph } = index;
    const workflows = graph.workflows.map((wf) => {
        const nodes = wf.nodeIds
            .map((id) => index.nodeById.get(id))
            .filter(Boolean) as WorkflowNode[];
        const files = new Set<string>();
        let hasLlmCalls = false;
        for (const n of nodes) {
            if (n.source?.file) files.add(n.source.file);
            if (n.type === "llm") hasLlmCalls = true;
        }
        return {
            id: wf.id,
            name: wf.name,
            description: wf.description ?? null,
            node_count: wf.nodeIds.length,
            has_llm_calls: hasLlmCalls,
            primary_files: [...files].slice(0, 5),
        };
    });

    return {
        workflows,
        total_nodes: graph.nodes.length,
        total_edges: graph.edges.length,
        llms_detected: graph.llms_detected,
    };
}

// ---------------------------------------------------------------------------
// get_workflow
// ---------------------------------------------------------------------------

export function getWorkflow(index: GraphIndex | null, workflowName: string) {
    if (!index) return NO_GRAPH;

    const { graph } = index;
    const nameLower = workflowName.toLowerCase();
    const wf = graph.workflows.find(
        (w) =>
            w.name.toLowerCase() === nameLower ||
            w.id.toLowerCase() === nameLower ||
            w.name.toLowerCase().includes(nameLower)
    );

    if (!wf) {
        const available = graph.workflows.map((w) => w.name);
        return {
            error: "workflow_not_found",
            message: `No workflow matching "${workflowName}"`,
            available_workflows: available,
        };
    }

    const nodeSet = new Set(wf.nodeIds);
    const nodes = wf.nodeIds
        .map((id) => {
            const n = index.nodeById.get(id);
            if (!n) return null;
            return {
                id: n.id,
                label: n.label,
                type: n.type,
                file: n.source?.file ?? null,
                line: n.source?.line ?? null,
                function: n.source?.function ?? null,
                model: n.model ?? null,
                temperature: n.temperature ?? null,
                description: n.description ?? null,
            };
        })
        .filter(Boolean);

    const edges = graph.edges
        .filter((e) => nodeSet.has(e.source) && nodeSet.has(e.target))
        .map((e) => ({
            from: e.source,
            to: e.target,
            label: e.label ?? null,
            condition: e.condition ?? null,
        }));

    const topoOrder = topologicalSort(wf.nodeIds, graph.edges);

    return {
        workflow: {
            id: wf.id,
            name: wf.name,
            description: wf.description ?? null,
            nodes,
            edges,
            topological_order: topoOrder,
            components: wf.components ?? [],
        },
    };
}

// ---------------------------------------------------------------------------
// get_node
// ---------------------------------------------------------------------------

export function getNode(index: GraphIndex | null, nodeId: string) {
    if (!index) return NO_GRAPH;

    const node = index.nodeById.get(nodeId);
    if (!node) {
        const suffix = nodeId.toLowerCase();
        const match = [...index.nodeById.values()].find(
            (n) =>
                n.id.toLowerCase() === suffix ||
                n.id.toLowerCase().endsWith("::" + suffix) ||
                (n.source?.function?.toLowerCase() === suffix)
        );
        if (!match) {
            return {
                error: "node_not_found",
                message: `No node matching "${nodeId}"`,
                hint: "Use list_workflows or get_file_context to discover node IDs",
            };
        }
        return buildNodeResponse(index, match);
    }

    return buildNodeResponse(index, node);
}

function buildNodeResponse(index: GraphIndex, node: WorkflowNode) {
    const wf = index.nodeToWorkflow.get(node.id);
    const incoming = index.incomingEdges.get(node.id) ?? [];
    const outgoing = index.outgoingEdges.get(node.id) ?? [];

    return {
        node: {
            id: node.id,
            label: node.label,
            description: node.description ?? null,
            type: node.type,
            model: node.model ?? null,
            temperature: node.temperature ?? null,
            source: node.source ?? null,
        },
        workflow: wf ? { id: wf.id, name: wf.name } : null,
        inputs: incoming.map((e) => ({
            from_node: e.source,
            label: e.label ?? null,
        })),
        outputs: outgoing.map((e) => ({
            to_node: e.target,
            label: e.label ?? null,
        })),
    };
}

// ---------------------------------------------------------------------------
// get_file_context
// ---------------------------------------------------------------------------

export function getFileContext(index: GraphIndex | null, files: string[]) {
    if (!index) return NO_GRAPH;

    const results: Array<{
        file: string;
        workflows: string[];
        nodes: Array<{
            id: string;
            label: string;
            type: string;
            line: number | null;
            function: string | null;
        }>;
        llm_calls: Array<{
            node_id: string;
            model: string | null;
            line: number | null;
        }>;
        connected_files: string[];
    }> = [];
    const notFound: string[] = [];

    for (const file of files) {
        let nodes = index.fileToNodes.get(file);
        if (!nodes) {
            const fileLower = file.toLowerCase();
            for (const [key, val] of index.fileToNodes) {
                if (key.toLowerCase().endsWith(fileLower) || fileLower.endsWith(key.toLowerCase())) {
                    nodes = val;
                    break;
                }
            }
        }

        if (!nodes || nodes.length === 0) {
            notFound.push(file);
            continue;
        }

        const workflowNames = new Set<string>();
        const connectedFiles = new Set<string>();

        for (const n of nodes) {
            const wf = index.nodeToWorkflow.get(n.id);
            if (wf) workflowNames.add(wf.name);

            for (const e of index.outgoingEdges.get(n.id) ?? []) {
                const target = index.nodeById.get(e.target);
                if (target?.source?.file) connectedFiles.add(target.source.file);
            }
            for (const e of index.incomingEdges.get(n.id) ?? []) {
                const source = index.nodeById.get(e.source);
                if (source?.source?.file) connectedFiles.add(source.source.file);
            }
        }

        for (const n of nodes) {
            if (n.source?.file) connectedFiles.delete(n.source.file);
        }

        results.push({
            file,
            workflows: [...workflowNames],
            nodes: nodes.map((n) => ({
                id: n.id,
                label: n.label,
                type: n.type,
                line: n.source?.line ?? null,
                function: n.source?.function ?? null,
            })),
            llm_calls: nodes
                .filter((n) => n.type === "llm")
                .map((n) => ({
                    node_id: n.id,
                    model: n.model ?? null,
                    line: n.source?.line ?? null,
                })),
            connected_files: [...connectedFiles],
        });
    }

    return {
        files: results,
        files_not_in_graph: notFound,
        graph_timestamp: new Date(index.timestamp).toISOString(),
    };
}
